---
layout: post
title: 14.2 函数式宏定义
---
##14.2 函数式宏定义
\#define TR "hello, world"这种宏定义可以称为变量式宏定义（Object-like Macro），宏定义名可以像变量一样在代码中使用。另外一种宏定义可以像函数调用一样在代码中使用，称为函数式宏定义（Function-like Macro）。例如编辑一个文件main.c：

	#define MAX(a, b) ((a)>(b)?(a):(b))
	k = MAX(i&0x0f, j&0x0f)

我们想看第二行的表达式展开成什么样，可以用gcc的-E选项或cpp命令，尽管这个C程序不合语法，但没关系，我们只做预处理而不编译，不会检查程序是否符合C语法。

	$ cpp main.c
	# 1 "main.c"
	# 1 "<built-in>"
	# 1 "<command-line>"
	# 1 "main.c"

	k = ((i&0x0f)>(j&0x0f)?(i&0x0f):(j&0x0f))

就像函数调用一样，把两个实参分别替换到宏定义中形参a和b的位置。注意这种函数式宏定义和真正的函数调用有什么不同：

1、函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心。

2、调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果MAX是个真正的函数，那么它的函数体return a > b ? a : b;要编译生成指令，代码中出现的每次调用也要编译生成传参指令和call指令。而如果MAX是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和call指令。所以，使用函数式宏定义编译生成的目标文件会比较大。

3、定义这种宏要格外小心，如果上面的定义写成#define MAX(a, b) (a>b?a:b)，省去内层括号，则宏展开就成了k = (i&0x0f>j&0x0f?i&0x0f:j&0x0f)，运算的优先级就错了。同样道理，这个宏定义的外层括号也是不能省的，想一想为什么。

4、调用函数时先求实参表达式的值再传给形参，如果实参表达式有Side Effect，那么这些Side Effect只发生一次。例如MAX(++a, ++b)，如果MAX是个真正的函数，a和b只增加一次。但如果MAX是上面那样的宏定义，则要展开成k = ((++a)>(++b)?(++a):(++b))，a和b就不一定是增加一次还是两次了。

5、即使实参没有Side Effect，使用函数式宏定义也往往会导致较低的代码执行效率。下面举一个极端的例子，也是个很有意思的例子。

	#define MAX(a, b) ((a)>(b)?(a):(b))

	int a[] = { 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 };

	int max(int n)
	{
		return n == 0 ? a[0] : MAX(a[n], max(n-1));
	}

	int main(void)
	{
		max(9);
		return 0;
	}

这段代码从一个数组中找出最大的数，如果MAX是个真正的函数，这个算法就是从前到后遍历一遍数组，时间复杂度是Θ(n)，而现在MAX是这样一个函数式宏定义，思考一下这个算法的时间复杂度是多少？
